# CS 160 Assignment 3: Code Generator for L1

**Assignment due: Tuesday, May 12 11:59 PM**

Read [The course description post on
Slack](https://cs160spring20.slack.com/archives/C010B82M9KL/p1585378023017500)
for late submission and slip day policy.

In this assignment, you are going to implement the last stage in our
compiler C1: the code generator.  The code generator will take an AST
as input and it will generate a list of x86 assembly instructions.

## What is provided

We provide you with the solution from assignment 1 and an `AST` class
that represents the AST nodes your parser needs to create, and a
minimal set of unit tests for sanity checking purposes. You are
encouraged to test your assignments with other test cases as well.

We will provide our solution parser once the slip day period for
assignment 2 has passed, then you can use that parser to help test
your code generator on source code files. In the meantime, you can
test your code generator using unit tests and handwritten ASTs and use
our provided parser binary to compile source code (as described
below).

We also provide the driver code in `main.cpp` that connects all
components of our compiler and optionally calls into the assembler and
the linker to produce an executable. We explain how to run the C1
compiler below.

Finally, we provide the bootstrap code that will call into the
compiled L1 program and it will print the output.

## What you need to implement

You need to implement the visitor methods of `CodeGen` class and the
`generateCode` method in the same class. The `generateCode` method is
the main entry point of the code generator and it will take an AST for
the whole program and it will return a vector of instructions,
assembly directives, and labels.

In order to implement the code generator, you will need to implement a
symbol table and keep track of information about functions, indices
for generating labels, and local and temporary variables.

### Starting point of your output programs

The bootstrap code we provide calls a function nameed `Entry` that
returns an integer. The main part of your program (the block and the
`output` part of the `Program` node) will be compiled to this
function. Because this function needs to be found by the bootstrap
code, you need to include the following assembler directives in your
output, right before the `Entry:` label:

```
        .globl Entry
        .type Entry, @function
```

## How to build the assignment

 - To build all the tests and executables, simply run `make`.
 - To build and run the tests, run `make test`.
 - To clean up the files created during the build, run `make clean`.

You can also give `make` argument `-jN` to run up to `N` processes
while building your code. This can reduce build times especially if
you just ran `make clean`.

The `Makefile` provided to you uses `g++` as the C++ compiler. We will
use `g++` to compile your code on GradeScope. We use `gcc` to compile
and link the bootstrap code, and GNU assembler `as` to generate an
object file from C1's output.

The template we provided works on CSIL as is so you do not need to
change the compiler on CSIL.

## How to test your code generator
We included some test inputs and expected output files in `tests/`
directory. You can directly use the `diff` tool to compare the code
generated by your compiler to the expected code. The expected assembly
program for each L1 source program is contained in
`tests/<test-name>.l1.expected-asm`.

You can `./compile_tests.sh` to compile, assemble, and link all tests.
For each test with the file name extension `.l1`, `./compile_tests.sh`
will create the following files as the output of running the compiler
(suppose the input file is called `tests/file.l1`):

 - `tests/file.l1.exe.asm` will contain the assembly program (the
   output of the code generator).
 - `tests/file.l1.exe.o` will contain the relocatable machine code
   (the output of the assembler).
 - `tests/file.l1.exe` will contain the executable machine code (the
   output of the linker).

You can compare the output of a test with the expected output like so
(here, the test is called `tests/add.l1`):

```
% diff -p -w tests/add.l1.expected-asm tests/add.l1.exe.asm
*** tests/add.l1.expected-asm	2020-05-01 14:02:16.522992527 -0700
--- tests/add.l1.exe.asm	2020-05-01 14:09:57.186287803 -0700
*************** Entry:
*** 9,15 ****
    mov %eax, -4(%ebp)
    movl $3, %eax
    mov -4(%ebp), %edx
-   add %edx, %eax
    add $4, %esp
    add $0, %esp
    movl %ebp, %esp
--- 9,14 ----
```

The `diff` command will show the lines where the difference is (here,
the result of the compiler is missing the `add %edx, %eax` instruction
so that line is marked with a `-`, the other lines are giving it
context).

We also created `codegen_test.cpp` in case you want to write your own
unit tests for the code generator.

### Testing with custom inputs

If you have custom L1 programs that you want to test your assignment
with, build the lexer by invoking `make` first. Then you can run the
compiler with one of the two options:

1. `./build/c1 <input-L1-program> --gen-asm-only <output-asm-file>`.

    This command compiles the given L1 program and writes the instructions
    generated by your code generator to `<ouput-asm-file>`.
2. `./build/c1 <input-L1-program> <output-executable>`.  This command
    first compiles given L1 program, then it runs the assembler and
    the linker to produce an executable:
    1. It compiles the program and writes the instructions generated
       by your code generator to `<output-executable>.asm` so you can
       still see the result.
    2. It runs GNU assembler (`as` command) to produce relocatable
       machine code (a.k.a. object code), the object code is saved to
       `<output-executable>.o`.
    3. It runs the linker (we use GCC as a linker so it runs `gcc`
       command) to link the object code with the bootstrap code to
       produce executable machine code. This stage assumes that the
       bootstrap code is located at `bootstrap.c` in current
       directory. The resulting executable machine code is saved to
       `<output-executable>`.

    Then, you can run the resulting executable program just like any
    compiled C program.

Note that the second invocation prints the commands it executes so if
a command fails you know exactly in which stage the failure occurred.

As another node, C1 calls the assembler with debug options, so you can
debug the resulting program with GDB if you want.

#### Examples

Supposed that `test.l1` contains the following L1 program:

```
def fact(int x): int {
	int result;
	if (x = 0) {
		result := 1;
	} else {
		int factXMinus1;
                factXMinus1 := fact(x - 1);
		result := x * factXMinus1;
	}
	return result;
}

int fact5;
fact5 := fact(5);

output fact5;
```

Let's run our compiler:

```
% ./build/c1 test.l1 test.exe
Lexing the input program 'test.l1'
Parsing the token stream
Generating code
Calling the assembler on the assembly code to build
Running assembler command: as --32 -g test.exe.asm -o test.exe.o
Compiling the bootstrap code
Running GCC: gcc -m32 -c bootstrap.c -o bootstrap.o
Linking the bootstrap code with L1 program object code
Running linker command: gcc -m32 bootstrap.o test.exe.o -o test.exe
```

As we can see, it first compiled our program through
Lexer->Parser->Code generator pipeline. Then it ran the following
commands (you don't need to run these manually):

```
as --32 -g test.exe.asm -o test.exe.o
```

This command calls the GNU assembler to convert the assembly program
to relocatable machine code.

```
gcc -m32 -c bootstrap.c -o bootstrap.o
```

This command calls the C compiler to compile and assemble the
bootstrapping code that will call our L1 program's entry point.

```
gcc -m32 bootstrap.o test.exe.o -o test.exe
```

This command calls the linker to link the bootstrapping code with our
relocatable machine code to produce an executable program.

Let's inspect the assembly code generated by the compiler first. If
you implemented your compiler correctly, you should see the following
output:

```
% cat test.exe.asm
fact:
  push %ebp
  movl %esp, %ebp
  sub $4, %esp
  movl $0, -4(%ebp)
  sub $4, %esp
  movl 8(%ebp), %eax
  mov %eax, -8(%ebp)
  movl $0, %eax
  mov -8(%ebp), %edx
  cmp %edx, %eax
  sete %al
  movzbl %al, %eax
  add $4, %esp
  cmp $0, %eax
  je IF_FALSE_0
  sub $0, %esp
  movl $1, %eax
  movl %eax, -4(%ebp)
  add $0, %esp
  jmp IF_END_0
IF_FALSE_0:
  sub $4, %esp
  movl $0, -12(%ebp)
  sub $4, %esp
  movl 8(%ebp), %eax
  mov %eax, -16(%ebp)
  movl $1, %eax
  mov -16(%ebp), %edx
  sub %eax, %edx
  mov %edx, %eax
  add $4, %esp
  push %eax
  call fact
  add $4, %esp
  movl %eax, -12(%ebp)
  sub $4, %esp
  movl 8(%ebp), %eax
  mov %eax, -20(%ebp)
  movl -12(%ebp), %eax
  mov -20(%ebp), %edx
  mul %edx
  add $4, %esp
  movl %eax, -4(%ebp)
  add $4, %esp
IF_END_0:
  movl -4(%ebp), %eax
  add $4, %esp
  movl %ebp, %esp
  pop %ebp
  ret
  .globl Entry
  .type Entry, @function
Entry:
  push %ebp
  movl %esp, %ebp
  sub $4, %esp
  movl $0, -4(%ebp)
  movl $5, %eax
  push %eax
  call fact
  add $4, %esp
  movl %eax, -4(%ebp)
  movl -4(%ebp), %eax
  add $4, %esp
  movl %ebp, %esp
  pop %ebp
  ret
```

Now, we can run the resulting executable and see the factorial of 5 as
the output:

```
% ./test.exe
120
```

### Testing via GradeScope

Later this week, we will enable submission via GradeScope and your
assignments will be tested against a comprehensive and much larger
test suite. Auto-grader on GradeScope will give you feedback on your
assignment as well. You will be able to submit your assignment
multiple times and get feedback before submitting a final solution.

We will explain the details on the auto-grader once it is online.

## x86 Resources

Here are some resources on x86. Also there are some notes about x86
below.

*Important note:* We are using the AT&T/GAS syntax, which is the one
with markers for registers (like EAX is denoted with `%eax`) and
constants (e.g., 0 is `$0`).

- x86 Assembly Wikibook: https://en.wikibooks.org/wiki/X86_Assembly
- An x86 instruction reference, you will not need most of the
  instructions here but it is useful for checking out how the
  instructions you want to use work: https://c9x.me/x86/

### Notes about x86 code

x86 is a quirky instruction set architecture. Here are some notes from
our experience implementing the compiler:

* Use IMUL instruction for multiplication. It takes two operands and
  does signed multiplication.
* We used only the following instructions so you do not need any other
  instructions to do the assignment: add, andl, orl, imul, movl,
  movzbl, sete, setl, setle, cmp, sub, je, jmp, call, ret, push, pop.

#### Result and other registers

We are using `EAX` as the result register (`RR` in the lectures), and
`EDX` as the other register (`OR` in the lectures. This setup allows
us to not have any caller or callee save registers under the x86 ABI.

#### `SETcc` family of instructions

The instructions `sete`, `setle`, `setl`, etc. set the operand based
on a previous comparison instruction. However, due to quirks of x86,
these instructions set an 8-bit register rather than a 32-bit
register. We need to zero-extend the result to the 32-bit result
register to store the result.

As an example, suppose that we are trying to store the result of EBX <
ECX into EAX. That is, EAX will be 1 if EBX < ECX, otherwise it will
be 0. Here is how we would do it:

```
  cmp %ebx, %ecx    ; compare EBX and ECX
  setl %al          ; set AL (the lowest byte of EAX) to 1 if EBX < ECX, 0 otherwise
  movzbl %al, %eax  ; zero-extend AL to EAX
```

#### Logical operations

The pseudo-instructions in the lectures contain logical `and` and `or`
operations. However, x86 contains only bitwise operations of these
kind. To make sure that you can use the bitwise `and`/`or`
instructions for this purpose, we are imposing the following
limitation to our code (note that this does not change the behavior of
our programs because relational expressions do not contain any
arithmetic values): all relational and logical operations should
produce 1 if the result is true, and 0 if the result is false.

Under this restriction, bitwise `and` and `or` behave like their
logical counterparts.

#### Negation

In our setting of relational and logical operators producing only 0
and 1, implementing negation is tricky because x86 does not have
logical negation instruction. To implement logical negation, we are
going to:

1. Compare the result (stored in EAX) to 0
2. If the result is equal to 0, produce a 1, otherwise produce a 0

So, the code for negation is:

```
  cmp $0, %eax      ; do the comparison
  sete %al          ; AL = 1 iff the result was 0
  movzbl %al, %eax  ; zero-extend AL to EAX so EAX=1 iff the result was 0
```

### Allocating variables in a block and temporary variables

We decided to implement temporaries without going back and changing
the allocated stack space at the beginning. Instead, each scope
allocates stack space necessary for that scope and releases the stack
space right when exiting the scope. This means that whenever the
program enters a block, it will immediately reserve the stack space
needed for all *non-temporary* variables declared in the block (even
when there are 0 variables, this part is just to keep the code
generator simple) and it will release this stack space right when
exiting the block.

Similarly, the generated code will allocate temporaries as it needs
and deallocate them once it no longer needs the temporary. This
approach has some tradeoffs compared to allocating the space at the
beginning of current scope:

- Simpler code generation: we generate the code to adjust the stack
just when we need a temporary rather than keeping a tally and
generating the code.
- Using less stack space at a given time: If we were to allocate the
  stack space at the beginning of the block, we could have had some
  unused space on the stack that would make the current stack frame
  larger hence it would waste space on the data cache for the callees
  and it could affect memory performance of recursive algorithms.
- Emitting more instructions: In our approach, each binary operation
  requires a temporary variable so we are generating 2 extra
  instructions (one for reserving the stack space, one for releasing)
  for each binary operation. Generating such instructions affect time
  performance of the generated program in multiple ways: it takes more
  cycles to calculate the same result (compared to reserving the space
  at the beginning) and it uses up space in the instruction cache.

To give an example, suppose we are generating code for `2 + 3`, the
addition code will need a temporary to store the left-hand side
value. Suppose there are no other variables on the stack. A correct
implementation should generate the following code (without comments):

```
  sub $4, %esp          ; Allocate space for tmp_0
  movl $2, %eax         ; Code generated for the left-hand side
  mov %eax, -4(%ebp)    ; Save the result of the left-hand side to [tmp_0]
  movl $3, %eax         ; Code generated for the right-hand side
  mov -4(%ebp), %edx    ; Load the result of the left-hand side from [tmp_0] to EDX (other register)
  add %edx, %eax        ; Compute the addition and save the result to result register
  add $4, %esp          ; End of the addition code, deallocate the stack space reserved for tmp_0
```

So, we are allocating temporary variables when an expression needs
them, then deallocating them. This makes their implementation quite
simple, for an expression that uses a temporary variable `tmp_N`, we
would generate the code:

```
  sub $4, %esp  ; Allocate space for tmp_N
  ...           ; Generate the code for computing the expression
  add $4, %esp  ; Free the stack space used for tmp_N
```

Let's look at another example to see when the temporary variables are
allocated in a complex instruction: Say, we are generating the code
for `(10 * 17) + (3 + 4)`. For the sake of simplicity, suppose there
are no other variables in the stack.  We would like to generate the
code for the outmost addition as follows:

```
  sub $4, %esp          ; Allocate space for tmp_0
  ...                   ; Generate the code for 10 * 17
  movl %eax, -4(%ebp)   ; Save the result on tmp_0
  ...                   ; Generate the code for 3 + 4
  movl -4(%ebp), %edx   ; Load the result from tmp_0
  add %edx, %eax        ; Perform the addition
  add $4, %esp          ; Release the space allocated for tmp_0
```

Now, we would need two more temporaries for the subexpressions `10 *
17` and `3 + 4`. Suppose the temporaries used there are `tmp_1` and
`tmp_2`. When the code generator is generating the code for `10 * 17`,
there is only one variable on the stack (`tmp_0`) so it will allocate
`tmp_1` at the offset -8. Similarly, when the code for `3 + 4` is
being generated, there is only `tmp_0` on the stack (because `tmp_1`
is no longer on the stack as the code using it would have finished by
the time the code for `3 + 4` starts executing) so `tmp_2` is also
allocated at the offset -8. The code generated for the whole expression would be:

```
  sub $4, %esp          ; Allocate space for tmp_0

  ;; CODE FOR 10 * 17
  sub $4, %esp          ; Allocate space for tmp_1
  movl $10, %eax        ; Code for int. expr. `10`
  movl %eax, -8(%ebp)   ; Save the result to tmp_1
  movl $17, %eax        ; Code for int. expr. `17`
  movl -8(%ebp), %edx   ; Load the result of left-hand-side of (10 * 17) from tmp_1 to %edx
  imul %edx, %eax       ; Compute 10 * 17
  add $4, %esp          ; Release the space for tmp_1
  ;; END OF CODE FOR 10 * 17

  movl %eax, -4(%ebp)   ; Save the result on tmp_0

  ;; CODE FOR 3 + 4
  sub $4, %esp          ; Allocate space for tmp_2
  movl $3, %eax        ; Code for int. expr. `3`
  movl %eax, -8(%ebp)   ; Save the result to tmp_2
  movl $4, %eax        ; Code for int. expr. `4`
  movl -8(%ebp), %edx   ; Load the result of left-hand-side of (3 + 4) from tmp_2 to %edx
  add %edx, %eax       ; Compute 3 + 4
  add $4, %esp          ; Release the space for tmp_2
  ;; END OF CODE FOR 3 + 4
  
  movl -4(%ebp), %edx   ; Load the result from tmp_0
  add %edx, %eax        ; Perform the addition (10 * 17) + (3 + 4)
  add $4, %esp          ; Release the space allocated for tmp_0
```

## What to submit

You are going to submit your whole assignment through GradeScope. We
are going to consider only your changes to `backend/codegen.cpp` and
`backend/codegen.h` while grading and ignore changes in other files
and additional files. We are going to clarify submission instructions
once GradeScope is online.

Your submitted `codegen.h` and `codegen.cpp` need to compile with the
skeleton code given to you, otherwise you automatically fail the
assignment.
